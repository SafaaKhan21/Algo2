/*Group members :
                Noof Patwa , 2111058 , B8
                Rania Daghestani , 2105893 , B8
                Dina Ghulam Saeed , 2110468 ,B8
                 Safaa Khan , 2110828 ,B0B
For Prim Algorithm :https://www.learnerslesson.com/Data-Structures-and-Algorithms/Prim's-Algorithm-Minimum-Spanning-Tree-Code.htm
For Kruskal Algoritm :https://www.learnerslesson.com/Data-Structures-and-Algorithms/Prim's-Algorithm-Minimum-Spanning-Tree-Code.htm*/

package GraphFramework;

import java.util.*;
public class HMPrimAlg extends MSTAlgorithm {
       Graph graph ;
       Vertex []v;
       int total;
    LinkedList<Integer> vertices;
      // Vertex vertices;
    LinkedList<LinkedList<Edge>>  adjcList;
    Map<Integer ,Integer> vertexVal;
    // Stores the Minimum spanning Tree

  public HMPrimAlg(Graph graph ){
       this.graph =graph ;
        adjcList = new LinkedList<>();
       vertices = new LinkedList<>();
        vertexVal = new LinkedHashMap<>();
        v =graph.getVertex();
        //total cost
        total =0;
        
        // Stores the Minimum spanning Tree
      
        MSTResultList=new  ArrayList<Edge>() ;
    
    }

    public void primMST(){

        vertexVal = new LinkedHashMap<>();

        // Vertex to Edge Map
        Map<Integer , Edge> vertexToEdge = new HashMap<>();

        ///heap
        int i=0;
         while(i<v.length&&v[i]!=null){
            // v[i].getLabel()+65)+""
            vertexVal.put(((Integer.parseInt(v[i].getLabel()))),Integer.MAX_VALUE);
            vertices.add(Integer.parseInt(v[i].getLabel()));
            i++;
        }


          MinHeap minHeap = new MinHeap(vertexVal);
        // Call buildHeap() to create the MinHeap
        minHeap.buildHeap();
        // Replace the value of start vertex to 0.
        int d=0;
       for( d=0 ;d<v.length;d++ ){
           if (v[d]!=null){
               
                   break;
                   }
    }
        //char)(v[d].getLabel()+65)+"")  
        minHeap.updateHeap(Integer.parseInt(v[d].getLabel()),0);

        // Continue until the Min-Heap is not empty.
         while(!minHeap.empty()){
            // Extract minimum value vertex from Map in Heap
            Integer  currentVertex = minHeap.deleteMin();
            // Need to get the edge for the vertex and add it to the Minimum Spanning Tree..
            // Just note, the edge for the source vertex will not be added.
            Edge  spanningTreeEdge = vertexToEdge.get(currentVertex);
            if(spanningTreeEdge != null) {
                //spanningTreeEdge.setParent(v[index])
                
                MSTResultList.add(spanningTreeEdge);
                total+=spanningTreeEdge.getWeight();
            }
           //to search about current vertex
             int index=0;
           for (int x=0;x<v.length;x++){
               if(v[x] !=null)  
               if (currentVertex==Integer.parseInt(v[x].getLabel())){
                   index =x;
                   break;
               }  
               
           }
            // Get all the adjacent vertices and iterate through them.
            for(Edge  edge : getEdges(v[index])){
                //ffff
                v[index].setIsVisited(true);
                //(char) (edge.getTarget().getLabel()+65)+"";
                Integer adjacentVertex = Integer.parseInt(edge.getTarget().getLabel());
                
                // We check if adjacent vertex exist in 'Map in Heap' and length of the edge is with this vertex
                // is greater than this edge length.
                if(minHeap.containsVertex(adjacentVertex) && minHeap.getWeight(adjacentVertex)> edge.getWeight()){
                
                    // Replace the edge length with this edge weight.
                    edge.setParent(v[index]);
                    minHeap.updateHeap(adjacentVertex, edge.getWeight());
                   // edge.setLength( edge.getWeight()*5);
                    vertexToEdge.put(adjacentVertex, edge);
                }
            }
        }
    }
//-------------------------------------------------------------
    //this method to get all edges of visited vertex 
    List<Edge> getEdges(Vertex vertex){
        
        List<Edge> edgeList = new LinkedList<>();
        int i = vertices.indexOf(vertex);
       
     Edge help =vertex.getEdges().getHead();
     
      while (help !=null){
          help.setSource(vertex);
        edgeList.add(help);
            help= help.getNext();
      }
       

        return edgeList;
    }

       @Override
  //-------------------------------------------------------------
 ///this method is used to display the result of thee Kruskal  Algorithm 
    
    public void displayResultingMST() {
        System.out.println("\n\n--------------------------------------------------------\n");
           System.out.println("\nThe phone network (minimum spanning tree) generated by Prim algorithm is as follows:\n");
    for (Edge edge : MSTResultList ) { 
         int i=0;
            for ( ;i<v.length;i++ ){
           if (v[i] !=null)
               if(v[i].getLabel().equals(edge.getSource().getLabel())){
                   //displayInfo() from  vertex class
                    v[i].displayInfo();
                  break;
               }
            }
          //displayInfo() from  Edge class
           edge.displayInfo();
           System.out.println();
    
    }
      System.out.println("The cost of designed phone network:"+getTotal() );
}
//-------------------------------------------------------------
    public int getTotal() {
        return total;
    }
//-------------------------------------------------------------
    public void setTotal(int total) {
        this.total = total;
    }
        
     
     
           
    
}

    

      
    
    
    
    

